---
title: "Train Your Own Neural Network"
date: 2020-04-03T12:06:33+03:00
type: "post"
---

These days applying Machine Learning and particularly Deep-Learning techiques in order to implement technical challenges are mentioned all over the place.
Many problems are tackled by modeling Neural-Networks, feeding them with tons of data and consequently they "learn" 
and turn artificially "smarter". Thanks to the progress of TBD

We, Humans, have an inferior processing speed of information.
<br/>
We can't read a million books over the course of our lifetime. 
<br/>
Neither can we manually code a billion lines of code, 
<br/>
speak fluently 100 different languages or paint million drawings. 
<br/>
<br/>
Yet, we are still able to accomplish quite a lot.
<br/>
Much more than we think we can. 
<br/>

There is the classic saying that _"Practice makes Perfect"_. 
<br/>This is partly true, because it's also that _"Practice also makes you Permanent"_.
TBD deliberate practice rears it head. But there are manifold ways to practice deliberately. 
<br/><br/>
I'd like this article to focus on what I would call _"Train Your Own Netural Technique"_ technique. Let's use the _TYONT_ for short for the rest of the post. 
The essence of _TYONT_ is feeding your brain with tons of data relevant to things you care about.
<br/>
<br/>
I'm dividing that data into 2 categories: Factual and Pattern-Oriented.
<br/>
<br/>
First the _Factual data_ that we care about - it may be general or domain/profession specific data.
<br/><br/>

### General factual data:
This is straightforward - pieces of data that are mere facts.
#### Examples:

* Historical 
<br/>
When did the French revolution took place?
<br/>
Who was the president of the United-States during World War II?  

* Wisdom Quotes 
<br/>
Remembering inspiring [quotes of Winston Churchill][churchill-quotes] such as 
<br/>
_"Success is never found. Failure is never fatal. Courage is the only thing."_ 

* Jokes 
<br/>
If you want to be the most funny guy in the room, you'd better own an arsenal of Jokes for almost any situation.

* Vocabulary 
<br/>
What's the meaning of TBD

<br/>
### Domain-specific factual data:
Since I'm a developer and this blog assumes its readers are too, I'll use programming factual data here but you could easily see how it translates 
to other professions.

* Shortcuts 
<br/>
How do I re-open Chrome's last closed Tab? 

* Commands 
<br/>
How do I discard the local git uncommitted changes via the command-line?

* Syntax / Libraries 
<br/>
How do I create a new module in that language?
<br/>
What's the 2nd parameter this common-library's function signature expects?
<br/>
<br/>

### Patterns:
Now, let's move on and talk about the more interesting category: Patterns.
As opposed to factual data which is well-defined, patterns aren't.
<br/>
When I'm refering to a _Pattern_ here, I refer to a core solution-technique which is relevant to a wide class of problems.
<br/>
If there is a problem with a unique (or rare) solution that isn't applicable to other similar - then I'd NOT consider it as a Pattern.
<br/>
<br/>
Although there is not a well-defined algorithm that given a challenge, could say if its solutions consist of common techniques or not - 
I'd still try my best to argue there is place for having that category. Please bear with me. 
<br/>
<br/>
So instead of writing: _"Challenges having common solutions that can be reused in many places"_ - I'd stick with the term a _Pattern_.
<br/>
I'm also aware that what one would consider a technique as a _Pattern_, another person wouldn't - and that's totaly fine.
<br/>
<br/>
What's important is that anyone will be able to execute his own classification and decide if he views it as a _Pattern_.
<br/>

Since it's an individual discernment - here are a few examples of stuff I'd call _Patterns_:

* Math
<br/>
Prove that the root of 2 is a irrational number.
<br/>
<br/>
Why a _Pattern_? - The classic solution is to the above is prove by contradiction.
I see it as a pattern since I can imagine many problems that would require me to use the solution.
Maybe I'll need to prove that root of 5 isn't a rational number of perhaps use that root of 2 isn't a rational in the context
of a Geometry problem. 

* Chess 
<br/>
Given the following board position - how can you do matt in 2 moves?
<br/>
<br/>
Why a _Pattern_? - The solution to the above is to sacrifice a chess item in order to win, I'd call it a pattern since there are 
endless similar board positions that will require me to sacrifice an item in order to make a progress/win/avoid immediate lose.

* Programming 
<br/>
How you'd implement a Linked-List in C? 
<br/>
<br/>
Why a _Pattern_? - I won't need to implement a linked-list on my next task, TBD


<br/>
Our brain is very good at recognizing patterns. Given an image, it'll detect objects in a fraction of a second. 
<br/>
<br/>
Math enthusiasts are able to receive a Math challenge and at once think of a few solving strategies that should be tackled and eliminate a dozen others.
That's because they have years of accumulated problem-solving knowledge.
<br/>
<br/>
Profesional Chess players view a past game board will instantly infer a lot about it, weight trade-offs and have a gut feeling what are the best
options for the next moves. That's owing to to years of playing and encountering innumerous situtations.
<br/>
<br/>
Why a past game board and not any arbitrary board positions? TBD
<br/>
<br/>
Experienced developers can start reading a high-quality codebase consisting of a few thousand lines of code and after a short while figure out 
their way through it. Then, they can deduce what regions lack structure and require more refactoring, suggest architectural changes,
and develop a feeling for the code.
They can do that since they've read and written tons of code.
<br/>
<br/>
Why high-quality code-base and not any random code-base? TBD
<br/>
<br/>
The more we'll feed our brains with varied inputs the, the greater our toolbox will be become.
It means we can solve not only more problems but also in more elegantly (and faster) since we'll have more options to choose from.
<br/>
<br/>
## How to Train?
Now, how to _TYONT_?
Again, let's split it into factual-data and _Patterns_.
<br/>
<br/>
### Factual-data Training:
In order to _TYONT_ with facts, we first need to decide what you kind of information we want to remember. 
We may want to extend your vocabulary, learn a new language, remember quotes and list goes and on.
My advice is to start with one or two topics as most.
<br/>
Then you should use the [Spaced-repetition][spaced-repetition] technique
in order to optimize what to study and when. This will assist you with remembering the most in less time and retain it better. 
<br/>
<br/>
I think it's a shame that most people aren't familiar with Spaced-repetition. It's so powerful and rewarding. 
I highly recommend using [anki][anki] for applying it. You can think about it as your agent that throws at you flash-cards with questions
and asks you to answer them. In order to make it as effective as you can, you're encouraged to create your own cards. 
It will assist with retaining the data most effectively.
<br/>
<br/>
In case you want to expand your vocabulary - [Super-Memo][supermemo] is the best Spaced-repetition resource I know of. 
Not only it asks you a question - after you want to see the answer, it will pronounce it.
The app offers as hints synonyms to the desired answer - another advantage of the app.
<br/>
<br/>
Spaced-repetition can be super-effective for programmers as well. A classic use-case is making flash-cards for keyboard shortcuts or shell commands.
Another good case is having flashcards for Syntax. It's true that we have Google and Stackoverflow and great IDEs extensions with auto-complete
and such. However, if you find yourself looking again for a method/standard-library function that you did already twice over the past week - 
it might be a good indiciationi to go the extra mile and try to save the Googling for the next time. 
<br/>
I personally strive to be able to write code in my daily job knowing that I can go and open an empty text editor without any plugin and code.
Don't get me wrong here - we are paid to solve problems not memorize stuff that can be picked up easily.
I'm suggesting that we're able streamlining common stuff that we repeatedly do. It's up to anyone to pin-point what's the stuff that seems to slow 
him down. 
<br/>
Moreover, I'd argue that most devlopers are using a dominant programming-language in 80% of their work time and a handful of keyboard shortcuts 
(or worse - using you the mouse). Imagine the ROI of boost the process of recalling a syntax/stdlib or shortcuts you're using on a daily basis.
<br/>
The real benefit won't be the time-savings - it'll be the context-switches reduction.
You'll find yourself much less Googling, searching Stack-overlow and losing focus.
<br/>
Now that we've covered the Spaced-repetition based training -  we're left with the _Patterns Training_.

<br/>
<br/>
### Patterns Training
<br/>
The answer to how to _TYONT_ using _Patterns Training_ is unsurprisingly less obvious. It's true that we can create a flash-cards for very-short math riddles in some cases, 
or take a Chess board and turn it into a flashcard. That'll work in many cases, but not always.
<br/>
For example, let's return to improving at reading source code. 
Flash-cards won't assist programmers here (mayn in learning shortcuts for better navigation). The path for getting better at such a skill should be by tailor it to your own needs.
One plan can be to go over 1000 lines of code of a some GitHub project on a daily basis. That will surely make us better at reading code.
<br/>
But it should be more deliberately planned. Let's say that we want to improve code understanding of a specific domain that interests us.
We could look for famous GitHub Open-Source projects in that domain. It's preferable that that code be written in programming-languages we know.
Then we can pick one or two projects and start reading them. It's preferable that the tests will have some API documentation and of-course tests (otherwise, how did they become
famous from the first place?).
<br/>
After being able to walk through 1-2 projects and 3rd one will become easier.




<br/>
## It that all?
<br/>
Absolutely not. The article by no means tries to argue that anyone can be good a math, a professional chess player,
world-class musician or a top-notch developer. You still need to have some talent TBD


<br/>
### Related Links:
* [Expertise is ‘Just’ Pattern Matching][expertise-is-just-pattern-matching]
* [Spaced repetition][spaced-repetition]
* [Ultralearning Environments: Why Where You Learn Determines How Much You Learn][ultralearning-environments]
* [Thesaurus][thesaurus]
* [SuperMemo.com - Learn fast and forget about forgetting][supermemo]
* [Execute Program - Learn programming tools fast. Then remember them][executeprogram]

[spaced-repetition]: https://en.wikipedia.org/wiki/Spaced_repetition
[churchill-quotes]: https://www.keepinspiring.me/winston-churchill-quotes/
[ultralearning-environments]: https://www.scotthyoung.com/blog/2019/01/03/ultralearning-environments/
[expertise-is-just-pattern-matching]: https://commoncog.com/blog/expertise-is-just-pattern-matching/
[supermemo]: https://www.supermemo.com/
[thesaurus]: https://www.thesaurus.com/
[anki]: https://apps.ankiweb.net/ 
[executeprogram]: https://www.executeprogram.com/
